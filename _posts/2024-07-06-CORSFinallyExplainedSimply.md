---
title: "CORS 쉽게 이해하기  드디어 설명 완료"
description: ""
coverImage: "/assets/img/2024-07-06-CORSFinallyExplainedSimply_0.png"
date: 2024-07-06 09:59
ogImage:
  url: /assets/img/2024-07-06-CORSFinallyExplainedSimply_0.png
tag: Tech
originalTitle: "CORS Finally Explained — Simply"
link: "https://medium.com/gitconnected/cors-finally-explained-simply-ae42b52a70a3"
---

/assets/img/2024-07-06-CORSFinallyExplainedSimply_0.png

/assets/img/2024-07-06-CORSFinallyExplainedSimply_1.png

위의 그림을 본 적 있나요? 아마도... 그리고 아마도 매우 자주...

위의 오류를 고치는 방법을 설명하는 수백만 개의 기사들이 있지만, 이 "Cross-Origin Resource Sharing" (CORS)이란 무엇이며 왜 존재하는 걸까요?

<div class="content-ad"></div>

왜요??

먼저 시나리오를 통해 왜라는 질문에 대한 답변을 시작해봅시다. 시간이 지남에 따라 어떻게 일어날 수 있는지 살펴보겠습니다.

상상해보세요: bank.com에 로그인합니다. 여러분의 은행 서비스인 bank.com입니다. 로그인 후에는 브라우저에 "세션 쿠키"가 저장됩니다. (세션 쿠키는 기본적으로 bank.com 뒤의 서버에게 귀하의 브라우저가 계정에 로그인되어 있다는 것을 알려줍니다). bank.com에 대한 모든 후속 요청은 이제 이 쿠키가 포함되며, 이를 통해 로그인되어 있음을 알 수 있습니다.
그럼 이제 메일함을 확인하기로 결정합니다. 수상한 이메일을 발견하고 당연히 링크를 클릭하여 attack.com으로 이동합니다. 다음으로, 이 웹사이트는 귀하의 은행 세부정보를 얻기 위해 bank.com에 요청을 보냅니다. bank.com은 여전히 그 세션 쿠키 덕분에 당신이 로그인되어 있다고 생각합니다... 이 쿠키는 브라우저에 저장되어 있습니다. bank.com 뒤의 서버에게는 당신이 은행 세부정보를 요청한 것처럼 보이기 때문에 정상적으로 다시 보내줍니다. 이제 attack.com은 이 정보에 액세스하고 이를 악의적으로 저장합니다.

사람들이 이것이 나쁜 것이라고 깨달았기 때문에 브라우저는 SOP (Same-Origin Policy)을 채택했습니다. 여러분의 브라우저는 bank.com에서 요청을 보내려는 것을 알게 되면 bank.com이외의 모든 위치에서 여러분이 요청하려고 한다면 차단할 것입니다. 이제 이것을 이해하는 것이 중요합니다 — 이것은 브라우저 기반의 정책입니다. bank.com은 실제로 요청이 어디에서 온 것인지 알 방법이 없으므로 CSRF와 같은 공격에 대해 많이 보호할 수 없습니다. 여러분이 사용하고 있는 브라우저가 들어와서 원래 정보를 요청하려고 하는 것처럼 보일 경우, 기본적으로 도메인 (scheme + 도메인 이름 + 포트, https//foo.com:4000, http//bar.org:3000 등...)에 대한 요청이 동일한 출처에 대해서만 보내도록 요청합니다.

<div class="content-ad"></div>

이제 이건 정말 좋았지만, 이것이 극도로 제한적이었습니다. 즉, 공개 API는 전혀 작동하지 않았습니다. 프록시 솔루션을 사용하지 않는 이상, 해당 API에서 데이터를 요청할 수 없었습니다.

CSRF

여기 중요한 점이 있어요: 서버는 요청이 어디에서 왔는지 어느 정도 알 수 있습니다. 요청에 "Origin" 헤더가 있으며, 요청을 보낸 출처를 보여줍니다. 예를 들어 위 예시에서 요청은 다음과 같을 것입니다.

```js
bank.com으로의 요청
{
  Headers: { Origin: http://attack.com }
}
```

<div class="content-ad"></div>

bank.com이론적으로는 원점이 합리적인 요청에만 응답하도록 확인해야 합니다. 대부분 그렇지만, SOP은 다소 제한적인 것 같아요.
여기서 CORS가 등장합니다.

CORS

예를 들어 example.com의 웹 애플리케이션이 bank.com에서 리소스를 요청하려고 할 때, 브라우저는 자동으로 Origin 헤더를 요청에 포함시켜요. 이 헤더는 요청이 어디에서 발생했는지를 나타냅니다 (example.com). 여기가 중요한 부분이에요: SOP 아래에서 이러한 교차 출처 요청을 직접 차단하는 대신, bank.com의 서버는 이 Origin 헤더를 검토하고 자체 CORS 정책에 따라 요청을 허용하거나 거부할 수 있어요.

bank.com은 example.com을 신뢰할 수 있거나 요청되는 리소스가 공개적으로 접근 가능한 경우, 특정 CORS 헤더인 Access-Control-Allow-Origin과 같은 CORS 헤더를 포함한 응답을 할 수 있어요. 이 헤더는 http://example.com과 같이 이 origin을 명시적으로 허용하거나, 모든 출처가 접속 가능한 공개 리소스인 경우 \*로 설정될 수 있어요.

<div class="content-ad"></div>

물론, 브라우저는 이 모든 것을 용이하게 처리해줍니다. 잘못된 부분이 있으면, 예상치 못한 에러를 만날 수 있어요.

그런데... 만약 요청에 Origin 헤더가 없다면 어떻게 될까요? 다른 헤더들이 많이 있다면서 기본 HTTP 메소드 중 하나를 사용하지 않는다면 어떻게 해야 할까요?

이러한 상황에서 CORS 처리는 "간단한 요청"이 아니므로 조금 더 복잡해집니다. 이때 CORS에서 "프리플라이트" 요청이라는 개념이 관련됩니다.

<div class="content-ad"></div>

서버에 있는 데이터를 수정할 수 있는 특정 유형의 요청에 대해서는 HTTP PUT, DELETE와 같은 메서드를 사용하거나 모든 요청에 자동으로 포함되지 않는 헤더를 사용하는 경우, 브라우저는 실제 요청을 보내기 전에 "프리플라이트" 요청을 먼저 보냅니다. 이 프리플라이트 요청은 HTTP OPTIONS 요청이며, 그 목적은 실제 요청을 전송해도 안전한지 서버와 확인하는 것입니다.

프리플라이트 요청에는 실제 요청의 HTTP 메서드와 헤더를 설명하는 헤더가 포함됩니다. 그런 다음 다음과 같은 일이 발생합니다:

- 서버 응답: 서버가 CORS 정책과 실제 요청을 지원하는 경우, 실제 요청에 대한 요청에 대한 허용된 메서드 및 헤더를 나타내는 헤더로 프리플라이트 요청에 응답합니다. 이는 Access-Control-Allow-Methods 및 Access-Control-Allow-Headers와 같은 헤더를 포함할 수 있습니다.
- 브라우저 결정: 서버의 프리플라이트 요청에 대한 응답을 기반으로, 브라우저는 실제 요청을 계속 진행할지 여부를 결정합니다. 서버의 응답이 요청이 허용된 것을 나타내면 브라우저가 요청을 보내고, 그렇지 않은 경우 요청을 차단하고 CORS 관련 오류가 발생할 수 있습니다.

결론

<div class="content-ad"></div>

이제는 CORS에 대해 조금 더 이해하셨을 것입니다. 가장 중요한 점은 이 모든 것이 브라우저 정책이며, 서버가 이를 준수하도록 코드화되어야 한다는 것입니다. 이는 여러분을 안전하게 보호하기 위한 조치입니다. Chrome을 사용 중이라면 잘못된 링크를 클릭해도 그리 많이 걱정할 필요가 없습니다(물론, 약간은 걱정해야 합니다:D). 그러나 이것은 절대적인 정책은 아닙니다. 표준을 준수하지 않는 일부 제3자 브라우저를 사용한다면 이 모든 것은 무용지물이 될 수 있습니다. 그래서 사용하는 소프트웨어에 대해 주의해야 합니다!
