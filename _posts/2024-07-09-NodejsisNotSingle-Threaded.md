---
title: "Nodejs는 왜 싱글 스레드가 아닐까"
description: ""
coverImage: "/assets/img/2024-07-09-NodejsisNotSingle-Threaded_0.png"
date: 2024-07-09 08:33
ogImage:
  url: /assets/img/2024-07-09-NodejsisNotSingle-Threaded_0.png
tag: Tech
originalTitle: "Node.js is Not Single-Threaded"
link: "https://medium.com/@tkachenko.hello/node-js-is-not-single-threaded-1383594dbd17"
---

Node.js는 혁신적인 단일 스레드 아키텍처를 활용하여 서버 자원을 더 효율적으로 활용하는 빠른 서버 플랫폼으로 알려져 있어요. 하지만 단일 스레드만을 사용하여 이런 놀라운 성능을 실제로 달성할 수 있는 걸까요? 답변은 놀라우실 것 같아요.

![Node.js는 싱글 스레드가 아니다](/assets/img/2024-07-09-NodejsisNotSingle-Threaded_0.png)

이 글에서는 Node.js 뒤에 숨겨진 모든 비밀과 마법을 매우 쉽게 알려드릴 거예요.

# 프로세스 대 스레드 ⚙️

<div class="content-ad"></div>

우리가 시작하기 전에, 프로세스와 스레드가 무엇인지 이해하고, 그들의 차이점과 유사점을 발견해야 합니다.

프로세스는 현재 실행 중인 프로그램의 인스턴스입니다. 각 프로세스는 다른 프로세스와 독립적으로 실행됩니다. 프로세스에는 여러 가지 중요한 리소스가 있습니다:

- 실행 코드;
- 데이터 세그먼트 — 어디서든 접근할 수 있어야 하는 전역 및 정적 변수를 포함합니다;
- 힙 — 동적 메모리 할당;
- 스택 — 지역 변수, 함수 인수 및 함수 호출;
- 레지스터 — CPU 내부에 직접적으로 있는 소규모, 빠른 저장 위치로, 프로그램 실행 중에 데이터를 일시적으로 보유하는 데 사용됩니다 (프로그램 포인터 및 스택 포인터와 같은).

스레드는 프로세스 내에서 실행되는 단일 실행 단위입니다. 한 프로세스 내에 여러 개의 스레드가 서로 다른 동작을 동시에 수행할 수 있습니다. 프로세스와 스레드는 실행 코드, 데이터 및 힙을 공유하지만, 스택과 레지스터는 각 스레드에 대해 별도로 할당됩니다.

<div class="content-ad"></div>

![Node.js is Not Single-Threaded](/assets/img/2024-07-09-NodejsisNotSingle-Threaded_1.png)

## 자바스크립트는 쓰레드를 사용하지 않습니다 ⚠️

용어의 오해를 피하기 위해 JavaScript 자체가 단일 스레드도 아니고 다중 스레드도 아님을 알아두는 것이 중요합니다. 이 언어는 스레딩과 아무 상관이 없습니다. 이것은 실행 플랫폼이 처리해야 하는 명령어 집합일 뿐입니다. 플랫폼은 이러한 명령어를 자신의 방식으로 처리합니다 — 단일 스레드든 다중 스레드든 말이죠.

# 입출력 작업 🧮

<div class="content-ad"></div>

(입력/출력 작업)은 일반적으로 다른 컴퓨터 작업에 비해 느리다고 여겨집니다. 여기에 몇 가지 예시가 있어요:

- 디스크에 데이터를 쓰기;
- 디스크에서 데이터 읽기;
- 사용자 입력을 기다리기(예: 마우스 클릭);
- HTTP 요청 보내기;
- 데이터베이스 작업 수행.

# I/O는 느립니다 🐢

디스크에서 데이터를 읽는 것이 왜 느린 것으로 여겨지는지 궁금할 수 있습니다. 그 이유는 하드웨어 구성 요소의 물리적 구현에 있어요.

<div class="content-ad"></div>

RAM에 액세스하는 시간은 나노초의 순서대로 이루어지지만, 디스크나 네트워크의 데이터에 액세스하는 데 걸리는 시간은 밀리초의 순서입니다.

대역폭에도 같은 원칙이 적용됩니다. RAM의 전송 속도는 일정하게 GB/s의 순서대로 있으며, 디스크나 네트워크의 전송 속도는 MB/s에서 낙관적으로 GB/s에 이를 수 있습니다.

게다가, 인간 요소를 고려해야 합니다. 많은 경우에 애플리케이션의 입력은 실제 사람(예: 키를 누름)에서 나옵니다. 따라서 I/O의 속도와 빈도는 기술적 측면에만 의존하는 것이 아닙니다.

# I/O 작업이 스레드를 차단합니다 🚧

<div class="content-ad"></div>

I/O 작업은 프로그램을 크게 느리게 만들 수 있어요. 쓰레드는 계속 차단되고, I/O 작업이 완료될 때까지 더 이상의 작업이 실행되지 않아요.

![Node.js is Not Single-Threaded](/assets/img/2024-07-09-NodejsisNotSingle-Threaded_2.png)

# 더 많은 쓰레드를 생성해요! 🤪

알겠어요, 그럼 프로그램 내에 더 많은 쓰레드를 생성해서 각 요청을 별도로 처리하는 것은 어떨까요? 좋은 생각 같지 않나요. 이제 각 클라이언트 요청은 고유한 쓰레드를 가지고 있고, 서버는 여러 요청을 동시에 처리할 수 있어요.

<div class="content-ad"></div>

![Image](/assets/img/2024-07-09-NodejsisNotSingle-Threaded_3.png)

프로그램은 각 스레드마다 추가 메모리와 CPU 리소스를 할당해야 합니다. 이는 합리적으로 들립니다. 그러나 스레드가 I/O 작업을 수행할 때 중요한 문제가 발생합니다. 그들은 대기하면서 대부분의 시간을 리소스를 사용하지 않는 0%를 사용합니다. 더 많은 스레드가 있을수록 더 비효율적으로 리소스가 사용됩니다.

게다가, 스레드를 관리하는 것은 경합 조건, 교착상태 및 라이브락과 같은 잠재적인 문제로 이어질 수 있는 어려운 작업입니다. 운영 체제는 스레드 간에 전환해야 하는데, 이로 인해 다중 스레딩에서 얻는 효율성 향상이 감소할 수 있습니다.

# 해결책은 무엇일까요? 🤔

<div class="content-ad"></div>

다행히도, 인류는 이미 이러한 종류의 작업을 효율적으로 수행하는 스마트 메커니즘을 발명했습니다.

이제 이벤트 디멀티플렉서를 소개합니다. 이는 멀티플렉싱이라는 프로세스를 포함합니다 - 이는 신호가 공유 자원 위에 하나의 신호로 결합되는 방법입니다. 목표는 부족한 자원(우리 경우에는 CPU와 RAM)을 공유하는 것입니다. 예를 들어, 통신에서 여러 전화 통화를 하나의 전선을 사용하여 전달할 수 있습니다.

![Event Demultiplexer](/assets/img/2024-07-09-NodejsisNotSingle-Threaded_4.png)

이벤트 디멀티플렉서의 책임은 다음 단계로 나뉩니다:

<div class="content-ad"></div>

- 이벤트 소스 식별하기. 각 소스는 이벤트를 생성할 수 있습니다;
- 이벤트 소스 등록하기. 등록에는 각 소스에 대해 모니터링할 이벤트를 지정하는 것이 포함됩니다;
- 이벤트를 기다리기;
- 이벤트 통지 보내기;

중요! 이벤트 디마룰티플렉서는 실제 세계에 존재하는 구성요소나 장치가 아닙니다. 이는 동시에 많은 이벤트를 효율적으로 처리하는 방법을 설명하기 위해 사용되는 이론적인 모델입니다.

이 복잡한 프로세스를 이해하기 위해 과거로 돌아가 봅시다. 오래된 전화교환 시스템을 상상해 보세요: 이벤트 소스(전화기)를 식별하고 등록하며 새로운 이벤트(전화)를 기다립니다. 새로운 이벤트(전화 통화)가 발생하면 교환 기기는 통지(전구를 켜는 것)를 전달합니다. 그런 다음 교환기 조작자는 통지에 반응하여 대상 전화번호를 확인하고 통화를 원하는 목적지로 전달합니다.

![이미지](/assets/img/2024-07-09-NodejsisNotSingle-Threaded_5.png)

<div class="content-ad"></div>

컴퓨터에 대해서도 원리는 같습니다. 다만, 소스의 역할은 파일 디스크립터, 네트워크 소켓, 타이머 또는 사용자 입력 장치와 같은 것들로 대체됩니다. 각 소스는 데이터를 읽을 수 있는지, 쓸 수 있는 공간이 있는지, 또는 연결 요청과 같은 이벤트를 생성할 수 있습니다.

각 운영 체제는 이미 이벤트 디멀티플렉서 메커니즘을 구현했습니다: epoll(Linux), kqueue(macOS), 이벤트 포트(Solaris), IOCP(Windows).

하지만 Node.js는 크로스 플랫폼입니다. 크로스 플랫폼 I/O를 지원하면서 전체 프로세스를 지배하기 위해 이러한 상호 플랫폼 및 플랫폼 내 복잡성을 캡슐화하고 Node의 상위 레이어를 위해 일반화된 API를 노출하는 추상화 계층이 있습니다.

# Libuv 더 위대해요 🏆

<div class="content-ad"></div>

<img src="/assets/img/2024-07-09-NodejsisNotSingle-Threaded_6.png" />

libuv를 환영합니다 - Node.js를 위해 개발된 원래의 C로 작성된 크로스 플랫폼 라이브러리입니다. 이 라이브러리는 다양한 운영 체제에서 비차단 I/O에 일관된 인터페이스를 제공하기 위해 개발되었습니다. Libuv는 시스템의 이벤트 디멀티플렉서와 함께 작동하며 두 가지 중요한 구성 요소를 포함합니다: 이벤트 큐와 이벤트 루프. 이러한 구성 요소는 동시에 작동하여 비차단 리소스를 효과적으로 처리합니다.

이벤트 큐는 이벤트 디멀티플렉서에 의해 모든 이벤트가 배치되는 데이터 구조입니다. 그리고 이벤트 루프가 큐가 비어질 때까지 이벤트를 차례대로 처리하기 위해 준비된대기열에 넣어 처리합니다.

이벤트 루프는 지속적으로 실행되는 프로세스로, 이벤트 큐에서 메시지를 기다리고 이를 적절한 핸들러에게 전달합니다.

<div class="content-ad"></div>

# 문제 해결 성공! 🥳

I/O 작업을 호출할 때 발생하는 일련의 과정은 다음과 같습니다:

- Libuv는 운영 체제에 따라 적절한 이벤트 디멀티플렉서를 초기화합니다.
- Node.js 해석기는 코드를 스캔하여 각 작업을 호출 스택에 넣습니다.
- Node.js는 호출 스택에서 작업을 순차적으로 실행합니다. 그러나 I/O 작업의 경우 Node.js는 이러한 작업을 블로킹하지 않는 방식으로 이벤트 디멀티플렉서로 전송합니다. 이 접근 방식은 해당 I/O 작업이 스레드를 차단하지 않고 다른 작업들이 동시에 실행되도록 보장합니다.
- 이벤트 디멀티플렉서는 I/O 작업의 소스를 식별하고 해당 작업을 운영 체제의 도구를 사용하여 등록합니다.
- 이벤트 디멀티플렉서는 소스(예: 네트워크 소켓)를 지속적으로 모니터링하여 이벤트(예: 데이터를 읽을 수 있는 경우)를 대기합니다.
- 이벤트가 발생하면(예: 데이터를 읽을 수 있는 경우) 이벤트 디멀티플렉서가 신호를 보내고 이벤트와 관련된 콜백을 이벤트 큐에 추가합니다.
- 이벤트 루프는 계속해서 이벤트 큐를 확인하고 이벤트 콜백을 처리합니다.

Node.js가 하는 일은 한 요청을 대기하는 동안 다른 요청을 처리할 수 있다는 것입니다. Node.js는 모든 요청이 동시에 수행되도록 기본적으로 구성되어 있어 다른 요청이 완료될 때까지 기다리지 않습니다.

<div class="content-ad"></div>

<img src="/assets/img/2024-07-09-NodejsisNotSingle-Threaded_7.png" />

와우! 문제가 해결된 것 같네요. 대부분의 블로킹 I/O 작업의 복잡성이 OS 개발자들에 의해 해결되어 Node.js는 단일 스레드에서 효율적으로 실행될 수 있습니다. 감사합니다!

# 문제가 해결되지 않았어요 🫠

하지만 libuv 구조를 자세히 살펴보면 흥미로운 측면을 발견할 수 있습니다:

<div class="content-ad"></div>

<img src="/assets/img/2024-07-09-NodejsisNotSingle-Threaded_8.png" />

기다려, 스레드 풀? 뭐라고요? 네, 지금 우리는 주요 질문에 답하기에 충분히 심층적으로 파고들었습니다 — 왜 Node.js가 (완전히) 싱글 스레드가 아닌지?

# 비밀 파헤치기 🤫

오케이, 우리에겐 강력한 도구와 운영 체제 유틸리티가 있어서 한 스레드에서 비동기 코드를 실행할 수 있습니다.

<div class="content-ad"></div>

하지만 여기 Event Demultiplexer에 문제가 있습니다. 각 OS에서 Event Demultiplexer의 구현이 다르기 때문에 일부 I/O 작업의 일부가 비동기적으로 완전히 지원되지 않습니다. 모든 다양한 유형의 I/O를 모든 다양한 유형의 OS 플랫폼에서 지원하는 것은 어렵습니다. 이러한 문제들은 특히 파일 I/O 구현과 관련이 있습니다. 이는 Node.js의 일부 DNS 기능에도 영향을 미칩니다.

그뿐만 아니라, 비동기적으로 완료할 수 없는 다른 유형의 I/O가 있습니다:

- 원격 서버를 쿼리해야 하는 경우 영향을 받을 수 있는 DNS 작업, 예를 들면 dns.lookup은 차단될 수 있습니다.
- 암호화와 같은 CPU 바운드 작업.
- ZIP 압축.

이러한 경우에는 스레드 풀을 사용하여 I/O 작업을 별도의 스레드에서 수행합니다(일반적으로 기본적으로 4개의 스레드가 있습니다). 따라서 완전한 Node.js 아키텍처 다이어그램은 다음과 같이 보일 것입니다:

<div class="content-ad"></div>

<img src="/assets/img/2024-07-09-NodejsisNotSingle-Threaded_9.png" />

네, Node.js 자체는 single-threaded입니다. 그러나 내부적으로 사용되는 라이브러리들은 그렇지 않습니다. 예를 들어 libuv와 스레드 풀은 일부 I/O 작업을 처리할 때 사용됩니다.

스레드 풀은 Tasks Queue와 함께 사용되어 blocking I/O 작업을 처리합니다. 기본적으로 스레드 풀에는 4개의 스레드가 포함되어 있지만, 추가적인 환경 변수를 제공하여 이 동작을 수정할 수 있습니다:

```js
UV_THREADPOOL_SIZE=8 node my_script.js
```

<div class="content-ad"></div>

I/O 작업을 비동기적으로 수행할 수 없을 때 발생하는 일들이 있습니다. 그러나 주요 차이점은 다음과 같습니다:

- 이벤트 디멀티플렉서가 I/O 작업의 소스를 식별하면 해당 작업을 작업 대기열(Task Queue)에 등록합니다.
- 스레드 풀은 계속해서 새로운 작업을 모니터링합니다.
- 새 작업이 작업 대기열에 추가되면 스레드 풀이 사전 정의된 스레드 중 하나를 사용하여 비동기적으로 처리합니다.
- 작업을 완료한 후, 스레드 풀은 이벤트 큐에 이벤트와 관련된 콜백을 추가하고 신호를 보냅니다.

이 곳에 마법은 없습니다. I/O는 실제로 블로킹되지 않을 수 없으며 현재는 그것을 달성할 방법이 없습니다. 데이터는 물리적 제약으로 인해 지시된 속도보다 빠르게 전송될 수 없습니다. 아무것도 완벽하지 않으므로 하드웨어 수준에서 데이터 전송 속도를 높이는 방법을 찾을 때까지 우리는 최적화된 알고리즘 집합을 사용하여 가능한 가장 효율적인 방법으로 비동기 작업을 수행합니다.

읽어 주셔서 감사합니다. 즐거운 하루 되세요 :)
