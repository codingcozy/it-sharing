---
title: "Polyfillio에 관한 무서운 이야기들 이제 시작일 뿐입니다"
description: ""
coverImage: "/assets/img/2024-07-12-ThoseScaryStoriesAboutPolyfillioTheyreJusttheBeginning_0.png"
date: 2024-07-12 18:30
ogImage:
  url: /assets/img/2024-07-12-ThoseScaryStoriesAboutPolyfillioTheyreJusttheBeginning_0.png
tag: Tech
originalTitle: "Those Scary Stories About Polyfill.io? They’re Just the Beginning"
link: "https://medium.com/@amy-blankenship/those-scary-stories-about-polyfill-io-theyre-just-the-beginning-5e24e7b5fe8a"
---

![image](/assets/img/2024-07-12-ThoseScaryStoriesAboutPolyfillioTheyreJusttheBeginning_0.png)

이번 주 인터넷이 폴리필(Polyfill.io)이 악성 코드를 삽입하고 있다는 소식으로 떠들썩했어요. 이 코드는 CDN에서 몇 년 동안 제공되어온 URL에서 이를 링크하는 웹사이트로부터 주입되었다고 해요.

그저 말이에요. Github 리포지토리 소유권과 다운로드 도메인이 2월에 이전되었어요. 이번 주까지 기다리지 않고 변경을 시작했어요. 제가 알고 있는 바로는 이렇습니다.

2월에, 일부 사용자가 로그인을 시도할 때 수수께끼 같은 오류가 발생하기 시작했어요. Sentry 오류 경계가 우리에게 제공하는 스택 추적은 아무 의미가 없었어요. 사용 중이던 okta-react 라이브러리 코드 안이었어요. 우리가 최근에 okta-react, okta-js 또는 sentry 코드를 업그레이드 하지 않았고, 호출한 코드도 그렇지 않았어요.

<div class="content-ad"></div>

요약하자면, 디버거를 사용하여 코드를 따라가는 과정에서 Okta의 일부 코드가 이터러블 속성이 있는 객체를 받을 것으로 기대했음을 발견했습니다. 때로는 객체를 수신할 때 해당 속성을 반복할 수 없는 경우가 있었습니다. 더 깊이 파고들어가보니 해당 객체가 폴리필 라이브러리 내부의 코드에서 반환된 것을 발견했습니다.

즉시 CDN 링크를 제거하여 버그를 수정했습니다. 또한 폰트 어썸과 구글 애널리틱스를 비롯한 다른 CDN 링크를 제거하기 위해 백로그에 티켓을 넣었습니다. 또한 LinkedIn에 게시물을 작성하여 경고했습니다.

우리는 이 사이트가 4개월 동안 폴리필 코드를 수정해온 것을 알고 있으며, 악의적인 코드 삽입이 이번 주부터 시작된 것은 아닌 것으로 판단됩니다. 솔직히 말해서 여기에도 게시하지 않은 것을 후회하지만, 솔직히 말해서 그 경고가 더 많은 주목을 받았을지도 확신할 수 없습니다.

주요 웹사이트, 우리 모두가 사용하는 웹사이트들이 여전히 이 구식 기술을 사용하고 있다는 사실을 심각하게 고려하지 않았습니다. 이 악의적인 사이트가 전 세계의 여러 사이트에서 자유롭게 원하는 대로 행동할 수 있는 네 피해가 어떤 것인지 정확히 알 방법은 없습니다. 아마도 모든 사람들이 어떤 형태로든 영향을 받았을 것으로 생각됩니다. 중국인들은 해킹에 대한 주의를 끌기 전에 사람들을 포르노 사이트로 보내면서 원하는 것을 얻은 것으로 생각합니다.

<div class="content-ad"></div>

# 어떻게 된 걸까요?

혹시 자신에게 물을 수 있는 질문은 어떻게 이런 일이 발생했는지일 것입니다. 왜 이렇게 많은 웹 사이트가 이 사이트로 링크를 걸어 연결이 중단된 것일까요? 이를 이해하려면 10년 전쯤의 웹이 어떠했는지 알아봐야 합니다. 그때는 모든 브라우저에서 표준이 완전히 채택되기까지 몇 년이 걸릴 수 있었습니다. 게다가 많은 기업들이 업그레이드를 승인하는 데 시간이 걸렸기 때문에 새로운 표준을 브라우저가 구현했다 하더라도 개발자들이 사용자가 이에 접근할 수 있다고 가정하기 어려웠습니다.

그래서 개발자들은 폴리필 라이브러리를 활용해 이를 해결했습니다. 표준이 마치 이미 시행된 것처럼 코드를 작성할 수 있었고, 기존의 계획대로 브라우저에서 해당 표준이 완전히 지원되면 폴리필을 원활하게 제거할 수 있을 것이라 생각했습니다.

그 마지막 부분은 어떻게 됐는지 모르겠군요. 우선, "오늘, 폴리필로 제공되던 모든 기능이 대다수의 사용자가 사용하는 브라우저에 완전히 구현되었다"는 발표가 한 번도 없었습니다. 그보다 중요한 것은, 개발자들이 프로젝트를 잊거나 다른 일로 넘어간다는 것입니다.

<div class="content-ad"></div>

혹은 우리가 논의할 때까지 백로그의 상단으로 올라가지 못합니다. 제 프로젝트에서는 CDN을 제거하기 위한 오픈 티켓이 있었지만, 문제가 발생하기 몇 주 전까지 기록되지 않았고 누구도 긴급한 우선순위로 생각하지 않았습니다. 오늘은 전 세계가 긴급한 우선순위로 생각하고 있군요.

좋은 소식은 이제는 별도의 폴리필이 필요하지 않습니다. 우리는 제거함으로써 발생하는 버그를 만나지 않아서 아마도 제거하는 데 추가 QA 주기가 필요하지 않을 것입니다. 업데이트: polyfill.io는 도메인 등록기관에 의해 중단되었으므로 사용 중이라면 QA를 진행하여 섬세한 변경 사항이 버그를 유발하는지 확인하십시오.

# 모든 오픈 소스 소프트웨어가 취약한가요?

이것은 복잡한 질문입니다. 답은 사용 방식에 따라 예와 아로 나뉩니다.

<div class="content-ad"></div>

이 코드의 큰 문제는 CDN(콘텐츠 전송 네트워크)를 통해 스크립트 태그를 통한 직접적인 링크로 연결되었다는 점입니다. 이것은 언제든지 사이트에서 실제로 실행되는 것을 정확히 알 수 없다는 것을 의미합니다. 브라우저는 크로스 사이트 스크립팅과 같은 것에 대한 내장된 보호 기능으로 보안이 강화되었습니다. 그러나 이러한 유형의 라이브러리가 창과 문서를 편집하기 때문에 그들이 더 이상 다른 사이트와 같이 보이지 않을지 확신할 수 없습니다.

이제는 코드가 CDN에서 제공되는 경우가 덜 흔하며, 글꼴과 같은 자산과 같은 주목할만한 예외가 있습니다. 따라서 npm이나 yarn을 통해 오픈 소스 라이브러리를 사용하는 경우에는 이러한 유형의 취약성이 발생하지 않습니다. 대신에 라이브러리 유지자가 무료로 작업하기 싫어지고 지속적으로 특징 요청이나 버그를 제기하며 여러 사람들이 괴롭히는 것에 지쳐서 코드를 망가뜨릴 결정을 내릴 수 있는 문제에 부딪힐 수 있습니다.

이를 방지하기 위해 반드시 package.json에서 근사값/호환 가능한 버전 대신 특정 버전을 사용하고 있도록 해야 합니다. 항상 lock 파일(packagelock.json 또는 yarn.lock)을 확인하여 서버에서 사용되는 라이브러리의 버전이 누군가의 로컬 머신에서 실행된 것임을 확인해야 합니다. 라이브러리 코드는 빌드 프로세스 중에 서버에 설치되어서 제어할 수 없는 장소에 물리적으로 위치하지 않습니다.

이것은 완벽하지는 않지만, 새 코드로 패키지 버전을 덮어쓸 수는 있지만 (합법적인) 유지자가 그런 일을 하는 것은 드물기 때문에 그렇게 되기는 힘듭니다. 라이브러리의 정확한 버전을 자체 호스팅하면(예: artifactory와 같은 곳), 추가적인 보안층을 제공할 수 있습니다.

<div class="content-ad"></div>

# 앞으로 나아가기

이것은 모두에게 큰 학습 경험이었습니다. 항상 안전한 코딩을 하고, 최선의 방법을 따르며, 실제로 문제가 발생하기 전에 무엇이 잘못될 수 있는지 생각해보세요.

즐거운 코딩 되세요!
