---
title: "Nodejs V8 엔진의 세부사항"
description: ""
coverImage: "/assets/img/2024-07-30-NodejsDetailsofV8Engine_0.png"
date: 2024-07-30 17:05
ogImage: 
  url: /assets/img/2024-07-30-NodejsDetailsofV8Engine_0.png
tag: Tech
originalTitle: "Nodejs Details of V8 Engine"
link: "https://medium.com/@profoliohub/node-js-details-of-v8-engine-6f86d475be5d"
---


Node.js 내부에 대한 심층 탐구를 계속할 것을 환영합니다! 이 게시물에서는 Node.js 뒤의 강력한 엔진인 V8 엔진을 살펴보겠습니다. 이 엔진은 놀라운 속도와 효율성으로 JavaScript 코드를 실행합니다. V8의 아키텍처를 이해하고 JavaScript 실행을 최적화하는 방법은 보다 효율적인 Node.js 애플리케이션을 작성하는 데 도움이 될 수 있습니다.

![V8 Engine](/assets/img/2024-07-30-NodejsDetailsofV8Engine_0.png)

## V8 엔진이란 무엇인가요?

V8 엔진은 구글에서 개발한 오픈 소스 JavaScript 엔진입니다. 이 엔진은 C++로 작성되었으며 Google Chrome 및 Node.js에서 JavaScript 코드를 실행하는 데 사용됩니다. V8은 JavaScript를 직접 네이티브 기계 코드로 컴파일한 후 실행하여 JavaScript 해석과 비교하여 상당한 성능 향상을 이뤄냅니다.

<div class="content-ad"></div>

## V8 엔진의 주요 구성 요소

V8 엔진은 JavaScript 실행을 최적화하기 위해 함께 작동하는 여러 가지 주요 구성 요소로 구성되어 있습니다:

- 분석기
- Ignition 해석기
- TurboFan 컴파일러
- 가비지 수집기

각 구성 요소를 자세히 살펴보겠습니다.

<div class="content-ad"></div>

# 파서

파서는 V8 엔진의 파이프라인에서 첫 번째 구성 요소입니다. 그 주요 역할은 JavaScript 코드를 추상 구문 트리 (AST)로 변환하는 것입니다. 이는 코드의 구조를 계층적으로 표현한 것입니다.

- 렉시컬 분석: 파서는 먼저 렉시컬 분석을 수행하여 소스 코드를 토큰으로 분해합니다. 토큰은 코드의 가장 작은 의미 단위입니다.
- 구문 분석: 그 다음 파서는 구문 분석을 수행하여 토큰을 코드의 구문 구조를 나타내는 트리 구조 (AST)로 배열합니다.

AST는 V8 파이프라인의 나머지 부분이 코드를 이해하고 최적화하는 데 사용하는 중요한 중간 표현입니다.

<div class="content-ad"></div>

# Ignition Interpreter

이그니션은 V8 엔진의 인터프리터입니다. 이그니션은 파서에 의해 생성된 AST를 가져와 바이트코드로 변환하여 코드의 낮은 수준 표현으로 효율적으로 실행할 수 있도록 합니다.

- 바이트코드 생성: 이그니션은 AST를 바이트코드로 변환하여 코드의 더 조밀하고 최적화된 표현으로 변환합니다.
- 실행: 그런 다음 바이트코드는 이그니션 인터프리터에 의해 실행됩니다. 바이트코드를 해석하는 것은 컴파일된 기계 코드를 실행하는 것보다 일반적으로 더 느리지만, 더 빠른 시작시간 및 동적 코드 변경의 효율적 처리를 가능하게 합니다.

이그니션의 주요 역할은 JavaScript 코드를 빠르고 효율적으로 실행하면서 성능을 최적화하기 위해 사용할 수 있는 프로파일링 정보를 수집하는 것입니다.

<div class="content-ad"></div>

# TurboFan 컴파일러

TurboFan은 V8 엔진의 최적화 컴파일러입니다. Ignition에 의해 실행된 바이트코드를 가져와 많이 최적화된 기계 코드로 컴파일하여 자주 실행되는 코드 경로의 성능을 향상시킵니다.

- 프로파일링: Ignition이 바이트코드를 실행하는 동안 코드의 동작에 대한 프로파일링 정보(자주 호출되는 함수, 자주 실행되는 루프 등)를 수집합니다.
- 최적화: TurboFan은 프로파일링 정보를 사용하여 다양한 최적화를 적용하며, 자주 호출되는 함수를 인라인으로 처리하고 죽은 코드를 제거하며 루프를 최적화합니다.
- 코드 생성: TurboFan은 CPU에서 직접 실행할 수 있는 매우 최적화된 기계 코드를 생성하여 상당한 성능 향상을 이끌어냅니다.

# Garbage Collector

<div class="content-ad"></div>

V8 엔진의 가비지 컬렉터는 메모리를 관리하고 사용되지 않는 자원을 회수하는 역할을 합니다. V8은 두 세대로 객체를 구분하는 세대별 가비지 컬렉션 전략을 사용합니다: 젊은 세대와 늙은 세대.

- 젊은 세대: 새로 할당된 객체는 젊은 세대에 배치됩니다. 대부분의 객체가 수명이 짧기 때문에 가비지 컬렉터는 이 부분의 메모리를 자주 수집하고 정리하여 신속하게 재할당할 수 있습니다.
- 늙은 세대: 젊은 세대에서 여러 번의 가비지 컬렉션 주기를 버텨낸 객체는 늙은 세대로 이동됩니다. 가비지 컬렉터는 이 부분을 덜 자주 수집하지만 더 철저한 최적화를 수행합니다.

V8은 메모리를 회수하고 단편화를 최소화하기 위해 마크-스위프트(mark-sweep) 및 마크-컴팩트(mark-compact) 알고리즘의 조합을 사용하여 효율적인 메모리 관리를 보장합니다.

# V8 최적화 기술

<div class="content-ad"></div>

V8 엔진은 자바스크립트 코드의 성능을 향상시키기 위해 다양한 최적화 기술을 사용합니다. 이러한 기술을 이해하면 더 성능이 우수한 코드를 작성할 수 있습니다:

- 인라인 캐싱: V8은 속성 액세스를 최적화하기 위해 인라인 캐싱을 사용합니다. 속성이 여러 번 액세스되면 V8은 속성의 위치를 캐시하여 매번 찾는 오버헤드를 줄입니다.
- 숨겨진 클래스: V8은 객체 속성 액세스를 최적화하기 위해 숨겨진 클래스를 사용합니다. 객체가 생성될 때 V8은 속성을 설명하는 숨겨진 클래스를 할당합니다. 속성이 추가되거나 수정될 때 V8은 새로운 숨겨진 클래스를 생성하고 객체를 새 클래스로 전환하여 빠른 속성 액세스를 가능하게 합니다.
- 코드 인라인: V8은 자주 호출되는 함수를 인라인화하여 함수 호출을 함수 본문으로 대체합니다. 이렇게 하면 함수를 호출하는 오버헤드가 줄어들고 추가 최적화가 가능해집니다.
- 죽은 코드 제거: V8은 실행되지 않는 코드를 제거하여 컴파일된 코드의 크기를 줄이고 성능을 향상시킵니다.
- 루프 최적화: V8은 루프에 다양한 최적화를 적용합니다. 작은 루프를 펼치거나 루프 외부로 불변 코드를 올리는 등의 최적화를 수행합니다.

# V8 성능 최적화의 실제 예제

## 예제 1: 인라인 캐싱을 사용한 속성 액세스 최적화

<div class="content-ad"></div>

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}

const p1 = new Point(1, 2);
const p2 = new Point(3, 4);

function sumPoints(p1, p2) {
  return p1.x + p1.y + p2.x + p2.y;
}

console.log(sumPoints(p1, p2));
```

이 예제에서 V8은 p1.x, p1.y, p2.x, 및 p2.y의 속성 접근을 최적화하기 위해 인라인 캐싱을 사용합니다. 속성에 처음 액세스할 때 V8은 그 위치를 캐시하여 후속 액세스가 더 빠르게 이루어질 수 있도록 합니다.

## 자세한 분석

객체 생성:

<div class="content-ad"></div>

- Point 생성자 함수는 x 및 y 속성을 가진 객체를 생성합니다.
- new Point(1, 2) 및 new Point(3, 4)를 호출하면 각각의 속성 값을 가진 두 Point 객체(p1 및 p2)가 생성됩니다.

속성에 액세스:

- sumPoints 함수는 p1 및 p2의 x 및 y 속성에 액세스합니다.
- 초기에 V8은 이러한 객체에서 x 및 y 속성이 어디에 있는지 찾아야 합니다. 이 작업은 반복적으로 수행될 경우 상대적으로 느릴 수 있는 찾기 프로세스를 포함합니다.

첫 번째 찾기 및 인라인 캐싱:

<div class="content-ad"></div>

- V8가 처음 p1.x를 찾을 때, p1 객체 내의 x 속성을 찾아야 합니다. 이 과정은 속성을 찾기 위해 객체의 숨겨진 클래스( V8의 최적화 기술)를 확인하는 과정을 포함합니다.
- V8가 p1.x를 찾으면, 이 속성의 위치를 나중에 액세스하기 위해 저장(또는 캐싱)합니다. 이것이 "인라인 캐시"입니다.

이후의 찾기:

- p1.y에 접근할 때, V8는 유사한 찾기를 수행하고 y의 위치를 캐싱합니다.
- p2.x와 p2.y에 대해서도 동일한 캐싱 메커니즘이 적용됩니다.

최적화된 속성 액세스:

<div class="content-ad"></div>

- 초기 룩업 및 캐싱 후에는 이러한 속성에 대한 후속 액세스가 빨라집니다. V8은 캐시된 위치를 사용하여 룩업을 다시 수행하는 대신 빠르게 액세스할 수 있습니다.
- sumPoints 함수에서 p1.x에 액세스하고 해당 위치가 캐싱되면, 다음에 p1.x가 필요할 때 V8은 캐시에서 직접 검색하여 룩업 프로세스를 우회합니다.

## 예시 2: 히든 클래스를 활용하여 객체 생성 최적화

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}

const points = [];
for (let i = 0; i < 1000; i++) {
  points.push(new Point(i, i + 1));
}
```

이 예시에서 V8은 Point 객체의 생성을 최적화하기 위해 히든 클래스를 사용합니다. 속성 x와 y가 객체에 추가될 때 V8은 빠른 속성 액세스를 가능케 하기 위해 히든 클래스를 생성하고 전환합니다.

<div class="content-ad"></div>

# V8과 Node.js: 강력한 조합

V8 엔진의 최적화와 효율적인 JavaScript 코드 실행은 Node.js가 빠르고 성능이 뛰어난 이유 중 하나입니다. V8이 어떻게 작동하는지 이해함으로써, 이러한 최적화를 완전히 활용할 수 있는 Node.js 애플리케이션을 작성할 수 있습니다.

## V8과 메모리 관리(Node.js)

메모리 관리는 모든 애플리케이션의 중요한 측면입니다. Node.js에서 V8 엔진의 가비지 수집기는 메모리 할당 및 해제를 처리하여 메모리 누수 없이 애플리케이션이 원활하게 실행되도록 합니다.

<div class="content-ad"></div>

- 메모리 할당: V8은 새로운 객체를 young generation에 메모리를 할당합니다. 객체가 생성되고 사용됨에 따라 V8은 그들의 참조와 사용 패턴을 추적합니다.
- 가비지 컬렉션: 메모리가 부족해지면 V8의 가비지 수집기가 실행되어 사용되지 않는 메모리를 회수합니다. V8은 mark-sweep 및 mark-compact 알고리즘을 사용하여 더 이상 필요하지 않은 메모리를 식별하고 해제합니다.
- 큰 객체 관리: young generation에 맞지 않는 큰 객체는 old generation에 직접 할당됩니다. V8의 가비지 수집기는 이러한 객체를 별도로 관리하여 효율적인 메모리 사용을 보장합니다.

## 효율적인 Node.js 코드 작성을 위한 실용적인 팁

- 불필요한 객체 생성 피하기: 가비지 컬렉션의 오버헤드를 줄이기 위해 불필요한 객체 생성을 최소화하고 가능한 경우 객체를 재사용합니다.
- 속성 액세스 최적화: V8의 인라인 캐싱 및 히든 클래스 최적화를 활성화하기 위해 객체 속성에 일관되게 액세스합니다.
- 전역 변수 최소화: V8의 최적화 노력을 방해하고 메모리 누수로 이어질 수 있으므로 전역 변수 사용을 피합니다.
- 효율적인 데이터 구조 사용: 사용 사례에 맞는 적절한 데이터 구조를 선택합니다. 예를 들어, 색인된 컬렉션에는 배열을 사용하고 키-값 쌍에는 객체를 사용합니다.
- 프로파일링 및 최적화: node --prof 및 clinic과 같은 프로파일링 도구를 사용하여 성능 병목 현상을 식별하고 코드를 최적화합니다.

## 결론

<div class="content-ad"></div>

V8 엔진은 Node.js의 강력한 구성 요소로, JavaScript 코드를 빠르고 효율적으로 실행할 수 있게 합니다. V8가 어떻게 작동하는지 이해하고 최적화 기술을 활용하면, 확장성이 좋고 사용자 경험이 훌륭한 고성능 Node.js 애플리케이션을 작성할 수 있습니다.

다음 글에서는 Libuv 라이브러리를 살펴보고, Node.js에서 비동기 I/O 작업과 이벤트 루프 관리 역할을 이해할 것입니다. 많은 기대 부탁드립니다!

구독하고 팔로우하여 Node.js 내부 세계로의 흥미로운 여정에 참여해주세요!

질문이나 의견을 자유롭게 남겨주세요. 학습 여정에서 도와드릴 수 있습니다.

<div class="content-ad"></div>

행복한 코딩하세요!