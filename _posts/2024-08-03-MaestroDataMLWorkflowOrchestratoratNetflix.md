---
title: "넷플릭스에서 데이터 ML 워크플로를 관리하는 Maestro의 모든 것"
description: ""
coverImage: "/assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_0.png"
date: 2024-08-03 21:17
ogImage: 
  url: /assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_0.png
tag: Tech
originalTitle: "Maestro Data ML Workflow Orchestrator at Netflix"
link: "https://medium.com/netflix-techblog/maestro-netflixs-workflow-orchestrator-ee13a06f9c78"
isUpdated: true
updatedAt: 1723816621100
---



Jun He, Natallia Dzenisenka, Praneeth Yenugutala, Yingyi Zhang, 그리고 Anjali Norwood님들의 작품

# TL;DR

저희는 Maestro 소스 코드를 이제 공개했다는 소식을 전합니다! 시작하려면 Maestro GitHub 저장소를 방문해 주세요. 유용하다면 별을 주시면 감사하겠습니다.

## Maestro란 무엇인가요?

<div class="content-ad"></div>

마에스트로는 대규모 데이터/머신러닝 워크플로우를 관리하기 위해 설계된 수평 확장 가능한 워크플로우 오케스트레이터입니다. 이는 데이터 파이프라인 및 머신러닝 모델 훈련 파이프라인과 같은 대규모 워크플로우를 관리합니다. 시작부터 끝까지 워크플로우의 전체 라이프사이클을 감독하며, 재시도, 대기열, 작업 배포, 컴퓨팅 엔진 등을 포함합니다. 사용자는 비즈니스 로직을 도커 이미지, 노트북, bash 스크립트, SQL, Python 등 다양한 형식으로 패키징할 수 있습니다. 전통적인 워크플로우 오케스트레이터가 방향성 비순환 그래프 (DAG)만 지원하는 것과 달리, 마에스트로는 비순환 및 순활 워크플로우를 모두 지원하며 foreach 루프, 하위 워크플로우, 조건부 분기 등 다양한 재사용 가능한 패턴도 포함하고 있습니다.

## 마에스트로와 함께한 여정

첫 블로그 게시물을 통해 마에스트로를 소개한 이후, 우리는 사용자를 대표하여 수십만 개워크플로우를 성공적으로 이동시켰습니다. 이전과 같은 중단 없는 전환이 이루어졌으며, 마에스트로는 우리의 늘어나는 작업 부하를 처리하여 디자인 목표를 충족했습니다. 지난 일년간 우리는 실행된 작업이 놀라운 87.5% 증가했습니다. 마에스트로는 현재 평균하루에 수천 개의 워크플로우 인스턴스를 시작하고, 평균하루 약 50만 건의 작업을 실행하며, 특히 바쁜 날에는 약 200만 건의 작업을 완료합니다.

## 확장성과 다양성

<div class="content-ad"></div>

마에스트로는 Netflix에서 수천 명의 최종 사용자, 애플리케이션 및 서비스에게 Workflow-as-a-Service를 제공하는 완전 관리형 워크플로 오케스트레이터입니다. ETL 파이프라인, ML 워크플로, AB 테스트 파이프라인, 서로 다른 스토리지 간 데이터 이동 파이프라인 등 다양한 워크플로 사용 사례를 지원합니다. 마에스트로의 수평적 확장성은 대규모의 워크플로 및 단일 워크플로 내에서 수많은 작업을 관리할 수 있음을 보장합니다.

Netflix에서는 워크플로가 복잡하게 연결되어 있습니다. 이를 더 작은 그룹으로 분할하고 다양한 클러스터 간에 관리하는 것은 불필요한 복잡성을 추가하고 사용자 경험을 저하시킵니다. 또한 이 방식은 이러한 조각화된 워크플로를 조정하기 위한 추가 메커니즘이 필요합니다. Netflix의 데이터 테이블이 단일 데이터 웨어하우스에 보관되어 있기 때문에 모든 테이블에 액세스하는 모든 워크플로를 처리할 단일 오케스트레이터가 필요하다고 믿습니다.

마에스트로 GitHub 저장소를 탐험하고 지속적인 개발에 기여함으로써 이 흥미로운 여정에 참여해 주십시오. 여러분의 지원과 피드백은 마에스트로 프로젝트의 지속적인 향상에 매우 중요합니다.

# 마에스트로 소개

<div class="content-ad"></div>

Netflix Maestro는 엔지니어와 비 엔지니어의 다양한 요구 사항을 충족시키도록 설계된 포괄적인 기능 세트를 제공합니다. 다양한 사용 사례에 적용되는 일반 기능 및 재사용 가능한 패턴이 느슨하게 결합된 방식으로 포함되어 있습니다.

워크플로우 정의는 JSON 형식으로 정의됩니다. Maestro는 사용자가 제공하는 필드와 Maestro가 관리하는 필드를 결합하여 유연하고 강력한 조정 정의를 형성합니다. 예시는 Maestro 저장소 위키에서 찾을 수 있습니다.

Maestro 워크플로우 정의는 속성 및 버전화된 워크플로우로 구성됩니다. 속성에는 작성자 및 소유자 정보, 실행 설정 등이 포함됩니다. Maestro는 작성자 및 소유자 정보, 실행 전략 및 동시성 설정과 같은 주요 속성을 워크플로우 버전 간에 유지하여 관리를 간편화하고 문제 해결을 도와줍니다. 현재 워크플로우의 소유권이 변경되면 새 소유자가 새로운 워크플로우 버전을 생성하지 않고도 워크플로우의 소유권을 주장할 수 있습니다. 사용자는 특정 워크플로우에서 트리거링 또는 경고 기능을 활성화할 수도 있습니다.

버전화된 워크플로우에는 고유 식별자, 이름, 설명, 태그, 타임아웃 설정 및 중요도 수준 (낮음, 중간, 높음)과 같은 속성이 포함됩니다. 각 워크플로우 변경은 새 버전을 생성하여 추적 및 쉬운 되돌림을 가능하게 하며, 기본적으로 활성 또는 최신 버전이 사용됩니다. 워크플로우는 사용자가 정의한 워크플로우 그래프의 노드인 스텝으로 구성됩니다. 스텝은 작업, 하위 워크플로우 스텝을 사용하는 다른 워크플로우 또는 foreach 스텝을 사용해 루프를 나타낼 수 있습니다. 스텝에는 고유 식별자, 스텝 타입, 태그, 입력 및 출력 스텝 매개변수, 스텝 종속성, 재시도 정책, 실패 모드, 스텝 출력 등이 포함됩니다. Maestro는 오류 유형을 기반으로 구성할 수 있는 재시도 정책을 지원하여 스텝의 내구성을 향상시킵니다.

<div class="content-ad"></div>

Netflix Maestro의 작업 흐름 정의와 속성에 대한 이 고수준 개요는 복잡한 작업 흐름을 정의하는 유연성을 강조합니다. 다음에는 다음 섹션에서 유용한 기능 중 일부를 살펴보겠습니다.

## 작업 흐름 실행 전략

사용자는 데이터 파이프라인을 자동화하고 실행 순서를 유지하고자 합니다. 작업 흐름이 병렬로 실행될 수 없거나 새로운 실행이 발생할 때 현재 실행을 중지해야 할 때 이는 중요합니다. Maestro는 작업 흐름이 실행되는지 여부를 결정하기 위해 미리 정의된 실행 전략을 사용합니다. 다음은 Maestro가 제공하는 미리 정의된 실행 전략 목록입니다.

순차 실행 전략
이는 FIFO(선입선출) 순서에 따라 한 번에 하나씩 작업 흐름을 실행하는 maestro에서 사용하는 기본 전략입니다. 이 실행 전략을 사용하면 Maestro는 트리거된 순서대로 작업 흐름을 실행합니다. 실행이 이전 상태에 의존하지 않음을 유의하십시오. 작업 흐름 인스턴스가 성공적이든 그렇지 않든 어느 한 시점에 도달하면 Maestro는 대기열에서 다음으로 시작합니다.

<div class="content-ad"></div>

엄격한 연속 실행 전략
이 실행 전략에 따르면 Maestro는 워크플로우를 트리거된 순서대로 실행하지만 워크플로우 인스턴스 히스토리에 차단 오류가 발생하면 실행을 차단합니다. 새롭게 트리거된 워크플로우 인스턴스는 차단된 오류가 해결될 때까지 대기열에 추가되며, 실패한 인스턴스를 수동으로 다시 시작하거나 실패한 인스턴스를 차단 해제로 표시해야 합니다.

![이미지](/assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_0.png)

위 예시에서 run5가 오전 5시에 실패하고 나중에 실행은 대기열에 추가되지만 실행되지 않습니다. 누군가 run5를 수동으로 차단 해제하거나 재시작하면 워크플로우 실행이 다시 시작됩니다. 이 실행 전략은 시간에 민감하지 않지만 비즈니스에 중요한 워크플로우에 유용합니다. 이를 통해 워크플로우 소유자가 나중에 실패 사항을 검토하고 정확성을 확인한 후 실행 차단을 해제할 수 있는 옵션이 제공됩니다.

첫 번째 실행 전략
이 실행 전략에 따르면 Maestro는 현재 실행 중인 워크플로우가 완료될 때까지 새로운 워크플로우 인스턴스를 대기열에 추가하지 않습니다. 현재 실행 중인 상태에서 새로운 워크플로우 인스턴스가 대기열에 추가되면 Maestro는 대기 중인 인스턴스를 제거합니다. 현재 실행 중인 워크플로우 인스턴스가 없을 때에만 새로운 워크플로우 인스턴스를 실행하며, 이를 통해 실행 전략을 통해 큐잉을 중지합니다. 새로운 워크플로우 인스턴스를 대기열에 추가하지 않아 불변성 문제를 피할 수 있습니다.

<div class="content-ad"></div>

마지막 실행 전략
이 실행 전략을 사용하면 Maestro는 실행 중인 워크플로우가 최신 트리거 된 것임을 보장하고 마지막 인스턴스만 유지합니다. 이미 실행 중인 워크플로우 인스턴스가 있을 때 새로운 워크플로우 인스턴스가 대기 중인 경우, Maestro는 실행 중인 인스턴스를 중지하고 새로 트리거된 것을 실행합니다. 이는 워크플로우가 항상 최신 데이터를 처리하도록 설계된 경우에 유용합니다. 예를 들어 매번 전체 테이블의 최신 스냅샷을 처리하는 경우와 같이.

동시성 제한과 병렬 실행 전략
이 실행 전략을 사용하면 Maestro는 미리 정의된 동시성 제한으로 제한되는 병렬로 여러 트리거된 워크플로우 인스턴스를 실행합니다. 이를 통해 실행을 분산시키고 대량의 데이터를 시간 제한 내에 처리할 수 있습니다. 이 전략의 일반적인 사용 사례는 이전 데이터를 백필링하는 것입니다.

## 매개변수 및 표현 언어 지원

Maestro에서 매개변수는 중요한 역할을 합니다. Maestro는 코드 삽입을 통해 동적 매개변수를 지원하는데, 이는 매우 유용하고 강력한 기능입니다. 이 기능은 획기적으로 워크플로의 유연성과 동적성을 향상시키며, 매개변수를 사용하여 실행 논리를 제어하고 워크플로 및 단계 간, 상위 및 하위 단계 간의 상태 공유를 가능하게 합니다. 다른 Maestro 기능과 함께 사용하면 워크플로를 동적으로 정의하고 복잡한 사용 사례에 대한 매개변수화된 워크플로를 정의할 수 있게 됩니다.

<div class="content-ad"></div>

그러나 코드 인젝션은 중대한 보안 및 안전 문제를 도입할 수 있습니다. 예를 들어, 사용자가 의도치 않게 무한 루프를 작성하여 배열을 생성하고 항목을 추가해 서버를 메모리 부족(OOM) 문제로 인해 충돌시킬 수 있습니다. 사용자에게 주입된 코드를 프로세스 정의 대신 비즈니스 로직에 포함시키도록 요구하는 접근 방법이 있을 수 있지만, 이는 사용자에게 추가 작업을 요구하고 비즈니스 로직을 프로세스와 밀접하게 결합시키게 됩니다. 이러한 경우에는 이러한 방법으로 인해 사용자들이 일부 복잡한 매개변수화된 프로세스를 설계할 수 없게 됩니다.

이러한 위험을 완화하고 사용자가 매개변수화된 프로세스를 구축하는 데 도움을 주기 위해 우리는 고유의 사용자 정의 표현 언어 파서를 개발했습니다. 이는 간단하고 안전한 표현 언어(SEL)로 코드 인젝션을 지원하며 구문 트리 파싱 중에 유효성 검사를 포함하여 시스템을 보호합니다. 이것은 Java Security Manager를 활용하여 액세스를 제한하여 코드 실행을 위한 안전하고 제어된 환경을 보장합니다.

간단하고 안전한 표현 언어 (SEL)
SEL은 Maestro 매개변수화된 프로세스 내의 코드 인젝션과 관련된 위험을 해결하기 위해 개발된 고유한 간단하고 안전한 표현 언어입니다. 이는 간단한 표현 언어이며 문법과 구문은 JLS (Java 언어 사양)을 따릅니다. SEL은 Maestro 사용 사례에 중점을 둔 JLS의 하위 집합을 지원합니다. 예를 들어, 모든 Maestro 매개변수 유형에 대한 데이터 유형, 오류 발생, 날짜 및 시간 처리, 그리고 많은 사전 정의된 유틸리티 메소드를 지원합니다. SEL은 루프 반복 제한, 배열 크기 확인, 객체 메모리 크기 제한 등 추가 런타임 체크를 포함하여 보안과 신뢰성을 향상시킵니다. SEL에 대한 자세한 내용은 Maestro GitHub 문서를 참조해 주세요.

출력 매개변수
매개변수 지원을 더욱 강화하기 위해, Maestro는 호출 가능한 단계 실행을 허용하여 사용자 실행에서 시스템으로 출력 매개변수를 반환할 수 있습니다. 출력 데이터는 Maestro의 REST API를 통해 Maestro로 전송되므로 단계 실행 중에 시스템이 Maestro 데이터베이스에 직접 액세스할 수 없습니다. 이 접근 방식은 보안 문제를 크게 줄여줍니다.

<div class="content-ad"></div>

매개변수화된 워크플로우
강력한 매개변수 지원 덕분에 사용자들은 정적 워크플로우 외에도 쉽게 매개변수화된 워크플로우를 생성할 수 있습니다. 사용자들은 매개변수화된 워크플로우를 정의하는 것을 즐기는데, 이는 복잡한 사용 사례를 해결할 수 있는 동시에 관리하고 문제 해결하기 쉽다는 강점을 지닐 뿐만 아니라 활용 가능한 기능입니다.

- 정적 워크플로우는 간단하고 사용하기 쉽지만 한계가 있습니다. 사용자들은 종종 동일한 워크플로우를 여러 번 복제하여 작은 변경을 수용해야 합니다. 게다가, 워크플로우와 작업은 매개변수를 사용하지 않으면 상태를 공유할 수 없습니다.
- 반면, 완전히 동적인 워크플로우를 관리하고 지원하는 것은 어려울 수 있습니다. 디버그하거나 문제 해결하기 어려우며, 다른 사람들이 재사용하기 어렵습니다.
- 매개변수화된 워크플로우는 사용자가 정의한 매개변수에 따라 실행 시 단계별로 초기화되어 균형을 유지합니다. 이 접근 방식은 사용자가 실행 시 실행을 제어할 수 있는 큰 유연성을 제공하면서 관리하기 쉽고 이해하기 쉽습니다.

이전 Maestro 블로그 게시물에서 언급한 대로, 매개변수 지원은 데이터 파이프라인과 같은 복잡한 매개변수화된 워크플로우의 생성을 가능케 합니다.

## 워크플로우 실행 패턴

<div class="content-ad"></div>

Maestro는 사용자가 데이터 플로우 패턴이나 다른 워크플로우 패턴을 쉽게 정의할 수 있도록 도와주는 여러 유용한 빌딩 블록을 제공합니다. Maestro 엔진 내에서 일반적인 패턴을 직접 지원함으로써 이러한 패턴을 최적화할 수 있을 뿐만 아니라 일관된 방식으로 구현할 수 있도록 보장합니다. 이제 Maestro가 제공하는 세 가지 주요 빌딩 블록에 대해 이야기해보겠습니다.

Foreach 지원
Maestro에서는 foreach 패턴을 원래의 워크플로우 정의 내에서 전용 단계로 모델링합니다. foreach 루프의 각 반복은 별도의 워크플로우 인스턴스로 내부적으로 처리되며, foreach 정의 블록 내에서 정의된 단계 실행(즉, 하위 그래프)에 따라 다른 Maestro 워크플로우와 유사하게 확장됩니다. foreach 단계 내에서 하위 그래프의 실행은 별도의 워크플로우 인스턴스로 위임됩니다. 그런 다음 foreach 단계는 단일 반복의 실행을 관리하는 각 foreach 워크플로우 인스턴스의 상태를 모니터링하고 수집합니다. 더 자세한 내용은 이전 Maestro 블로그 게시물을 참조해주세요.

foreach 패턴은 데이터 백필링이나 머신 러닝 모델 튜닝과 같이 다른 매개변수로 동일한 작업을 반복적으로 실행하는 데 자주 사용됩니다. 워크플로우 정의에서 각 반복을 명시적으로 정의해야 하는 것은 지루하고 시간이 많이 소요될 것입니다(수십만 개의 반복 가능성). 또한 foreach 범위가 변경되면 사용자는 새로운 워크플로우를 작성해야 하므로 프로세스가 더 복잡해집니다.

조건부 브랜치 지원
조건부 브랜치 기능을 사용하면 상위 단계에서 특정 조건이 충족될 때만 후속 단계를 실행할 수 있습니다. 이러한 조건은 SEL 표현 언어를 사용하여 실행 시 평가됩니다. 다른 빌딩 블록과 함께 결합하여 사용자는 강력한 워크플로우를 구성할 수 있습니다. 예를 들어 감사 확인 단계가 실패하면 보정 작업을 수행한 후 작업을 다시 실행하는 등의 작업을 수행할 수 있습니다.

<div class="content-ad"></div>

하위 워크플로 지원
하위 워크플로 기능을 사용하면 워크플로 단계가 다른 워크플로를 실행할 수 있어서 여러 워크플로 간에 공통 기능을 공유할 수 있습니다. 이를 통해 "함수로서의 워크플로"를 효과적으로 실행시키며 사용자가 워크플로 그래프를 구성할 수 있습니다. 예를 들어, 여러 팀이 제공한 하위 워크플로로 데이터 처리를 위한 수백 개의 테이블을 거치는 복잡한 워크플로가 관찰되었습니다.

이러한 패턴들을 결합하여 복잡한 워크플로 사용 사례에 대한 복합 패턴을 구성할 수 있습니다. 예를 들어, 하위 워크플로 집합을 순환하거나 중첩된 foreach 루프를 실행할 수 있습니다. Maestro 사용자들이 개발한 한 예시는 조건 분기와 하위 워크플로 기능을 모두 활용하여 오류를 처리하고 작업을 자동으로 다시 시도하는 자동 복구 워크플로입니다.

![이미지](/assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_1.png)

이 예시에서 `job1`이라는 하위 워크플로가 ETL(데이터 추출-변환-로드) 및 감사 작업으로 구성된 다른 워크플로를 실행합니다. 그 다음 상태 확인 작업이 Maestro 매개변수와 SEL 지원을 활용하여 이전 작업의 상태를 검색합니다. 이 상태를 기반으로 워크플로를 완료할지 데이터 문제를 해결할 복구 작업을 실행할지 결정할 수 있습니다. 문제를 해결한 후에는 하위 워크플로 `job2`를 실행하여 `job1`과 동일한 워크플로를 실행합니다.

<div class="content-ad"></div>

## 단계 실행 및 단계 매개변수

단계 실행 인터페이스
Maestro에서는 실행 시간에 작업을 설명하는 데 단계 실행을 사용합니다. 단계 실행 인터페이스는 다음 두 가지 정보를 정의합니다:

- 실행 시간에 단계 인스턴스의 동작을 제어하는 기본 API 세트.
- 단계 실행 상태와 실행 결과를 추적하기 위한 간단한 데이터 구조.

Maestro는 반복 단계 실행, 서브워크플로우 단계 실행과 같은 몇 가지 단계 실행 구현을 제공합니다 (이전 섹션에서 언급됨). 각 구현은 자체 논리를 정의하여 시작, 실행 및 종료 작업을 수행합니다. 실행 중에 이러한 작업은 단계 인스턴스를 초기화하는 방법, 비즈니스 로직을 수행하는 방법 및 특정 조건 (예: 사용자에 의한 수동 개입) 하에 실행을 종료하는 방법을 제어합니다.

<div class="content-ad"></div>

또한, Maestro 단계 실행 시간은 내부적으로 실행 상태 및 단계의 실행 결과를 추적합니다. 실행 상태는 단계의 다음 상태 전환을 결정하고 실패했는지 또는 종료되었는지 여부를 알려줍니다. 실행 결과에는 단계 아티팩트 및 단계 실행 이력 타임라인이 함께 포함되어 있어 후속 단계에서 접근할 수 있습니다.

단계 매개변수 병합
동적 방식으로 단계 동작을 제어하기 위해 Maestro는 단계 실행시 런타임 매개변수 및 태그 삽입을 지원합니다. 이를 통해 Maestro 단계는 시작되기 전에 런타임 변경(즉, 재정의된 매개변수)을 더 잘 수용할 수 있습니다. Maestro는 처음에 비어 있던 단계 매개변수 맵을 관리하고 있으며 아래 순서로 단계 매개변수를 병합함으로써 업데이트합니다:

- 기본 일반 매개변수: 매개변수 병합은 모든 단계에 있어야 하는 기본 매개변수부터 시작합니다. 예를 들어 workflow_instance_id, step_instance_uuid, step_attempt_id 및 step_id는 각 Maestro 단계에 필요한 매개변수입니다. 이러한 매개변수는 Maestro에 의해 예약되어 있으며 사용자가 전달할 수 없습니다.
- 삽입된 매개변수: Maestro는 삽입된 매개변수(있는 경우)를 매개변수 맵에 병합합니다. 삽입된 매개변수는 단계 실행에서 제공되며 단계 스키마에 기반하여 동적으로 생성됩니다. 각 단계 유형은 해당 단계에 관련된 특정 매개변수를 갖는 자체 스키마를 가질 수 있습니다. 스텝 스키마는 Maestro 코드를 업데이트할 필요 없이 독립적으로 발전할 수 있습니다.
- 기본 유형 매개변수: 런타임 매개변수 삽입 이후 Maestro는 특정 유형의 단계와 관련된 기본 매개변수를 병합하려고 시도합니다. 예를 들어, foreach 단계에는 내부적으로 설정되어 있고 foreach 단계에만 사용되는 loop_params 및 loop_index 기본 매개변수가 있습니다.
- 워크플로 및 단계 정보 매개변수: 이러한 매개변수에는 단계 정보와 해당 워크플로에 대한 정보가 포함됩니다. 이는 식별 정보 (예: workflow_id)일 수 있으며 존재할 경우 단계 매개변수 맵에 병합됩니다.
- 정의되지 않은 새 매개변수: Maestro 워크플로 인스턴스를 시작하거나 다시 시작할 때 사용자가 초기 단계 정의에 존재하지 않는 새 단계 매개변수를 지정할 수 있습니다. ParamsManager는 이러한 매개변수를 병합하여 실행 시간에 사용 가능하도록 합니다.
- 단계 정의 매개변수: 이러한 단계 매개변수는 사용자가 정의 시간에 정의하고, 비어있지 않으면 병합됩니다.
- 실행 및 다시 시작 매개변수: Maestro 워크플로 인스턴스를 시작하거나 다시 시작할 때 사용자가 실행 또는 다시 시작 매개변수를 제공하여 정의된 매개변수를 재정의할 수 있습니다. 이 두 유형의 매개변수는 마지막에 병합되어 단계 실행이 가장 최신과 정확한 매개변수 공간을 볼 수 있도록 합니다.

매개변수 병합 로직을 아래 다이어그램에서 시각화할 수 있습니다.

<div class="content-ad"></div>


![Image](/assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_2.png)

## 단계 의존성 및 신호

마에스트로 실행 흐름 그래프의 단계는 단계 의존성을 사용하여 실행 의존성을 나타낼 수 있습니다. 단계 의존성은 단계가 실행을 시작하기 위해 필요한 데이터 관련 조건을 지정합니다. 이러한 조건은 일반적으로 신호를 기반으로 정의됩니다. 신호는 매개변수 값과 같은 정보를 운반하는 메시지 조각이며 단계 출력 또는 SNS 또는 Kafka 메시지와 같은 외부 시스템을 통해 게시할 수 있습니다.

마에스트로의 신호는 신호 트리거 패턴을 제공하며 신호 의존성(발행자-구독자) 패턴을 제공합니다. 한 단계는 출력 신호(샘플 예제)를 게시할 수 있으며, 해당 신호에 종속적인 여러 다른 단계의 실행을 비로소 시작할 수 있습니다. 신호 정의에는 매핑된 매개변수 목록이 포함되어 있으며 마에스트로는 필드 하위 집합에서 "신호 일치"를 수행할 수 있습니다. 또한, 마에스트로는 신호 매개변수 값을 기준으로 ',' 등의 신호 연산자를 지원합니다.


<div class="content-ad"></div>

넷플릭스는 신호 개념 위에 다양한 추상화를 구축했습니다. 예를 들어, ETL 워크플로우는 데이터로 테이블을 업데이트하고 해당 데이터에 의존하는 하향 워크플로에 있는 단계를 차단 해제하는 신호를 보낼 수 있습니다. Maestro는 “신호 계통”을 지원하여 사용자가 신호의 모든 이전 인스턴스와 해당 신호와 일치하는(즉, 발행 또는 소비하는) 워크플로 단계를 탐색할 수 있습니다. 신호 트리거링은 신호를 구독하거나 결합된 신호 세트에 대한 워크플로의 실행을 정확히 한 번 보장합니다. 이 방식은 신호에서 지정된 조건이 충족될 때에만 워크플로 또는 단계를 실행하여 효율적입니다. 고급 추상화를 위해 신호 서비스가 구현되었습니다. 이에 대한 자세한 내용은 Maestro 블로그를 참조해주세요.

## 중단점

Maestro를 사용하면 사용자가 워크플로 단계에 중단점을 설정할 수 있습니다. IDE의 코드 수준 중단점과 유사하게 작동합니다. 워크플로 인스턴스가 실행되고 중단점이 있는 단계에 도달하면 해당 단계가 “일시 정지” 상태로 들어갑니다. 이것은 사용자가 중단점에서 수동으로 다시 시작할 때까지 워크플로 그래프의 진행을 중지합니다. 여러 워크플로 단계 인스턴스가 중단점에서 일시 정지되어 있을 때, 하나의 인스턴스를 재개하면 해당 특정 인스턴스만 영향을 받고 다른 인스턴스는 일시 정지 상태로 유지됩니다. 중단점을 삭제하면 모든 일시 정지된 단계 인스턴스가 계속됩니다.

이 기능은 특히 워크플로의 초기 개발 중에 유용하며, 사용자가 단계 실행과 출력 데이터를 검사할 수 있습니다. 여러 번 "foreach" 패턴으로 단계를 실행할 때도 유용합니다. 단계에 단일 중단점을 설정하면 foreach 루프의 모든 반복이 디버깅 목적으로 해당 단계에서 일시 중지됩니다. 또한 중단점 기능은 워크플로 실행 중에 인간 개입을 허용하며, 워크플로가 실행되는 동안 단계 상태를 변조하는 데 사용될 수도 있습니다.

<div class="content-ad"></div>

## 타임라인

Maestro에는 실행 단계 타임라인이 포함되어 있습니다. 실행 상태 머신 변경 및 해당 변경 이유와 같은 모든 중요 이벤트를 기록합니다. 이 기능은 디버깅에 유용하며 단계의 상태에 대한 통찰을 제공합니다. 예를 들어 "생성됨" 및 "매개 변수 평가 중"과 같은 전환을 로깅합니다. 매트릭스 타임라인 예시를 참고용으로 여기에 포함하였습니다. 구현된 단계 실행 시간은 타임라인 이벤트를 추가하여 실행 정보를 최종 사용자에게 제공할 수 있습니다.

## 재시도 정책

마에스트로는 실패로 인해 종단 상태에 도달하는 단계에 대한 재시도 정책을 지원합니다. 사용자는 재시도 횟수를 지정하고, 재시도 사이의 지연 및 지수적 백오프 전략을 비롯한 재시도 정책을 구성할 수 있습니다. 또한 고정 간격 재시도를 포함합니다. 마에스트로는 "플랫폼"과 "사용자" 두 가지 유형의 재시도를 구분합니다. 플랫폼 재시도는 사용자 논리와 관련되지 않은 플랫폼 수준 오류를 다루며, 사용자 재시도는 사용자가 정의한 조건에 대한 것입니다. 각 유형은 고유한 재시도 정책을 가질 수 있습니다.

<div class="content-ad"></div>

자동 재시도는 사용자 개입 없이 해결할 수 있는 일시적 오류를 처리하는 데 유용합니다. Maestro는 무사용 중단 단계에 대해 재시도를 0으로 설정하여 재시도를 피할 수 있는 유연성을 제공합니다. 이 기능을 통해 사용자는 재시도가 어떻게 관리되는지를 특정 요구 사항에 기반하여 제어할 수 있습니다.

## 집계된 보기

워크플로 인스턴스는 여러 실행을 가질 수 있기 때문에 사용자가 워크플로 인스턴스의 모든 단계의 집계된 상태를 보는 것이 중요합니다. 집계된 보기는 기본 집계된 보기를 현재 실행 인스턴스 단계 상태와 병합하여 계산됩니다. 예를 들어, 아래 그림에서 볼 수 있는 것처럼 간단한 경우를 시뮬레이션한 경우, step1과 step2가 성공하고 step3가 실패한 첫 번째 실행이 있으며, step4와 step5는 시작되지 않았습니다. 사용자가 실행을 다시 시작하면, 첫 번째 실행에서 성공한 step1과 step2가 스킵되고 step3에서 실행 2가 시작됩니다. 모든 단계가 성공한 후, 집계된 보기는 모든 단계에 대한 실행 상태를 표시합니다.

![마에스트로 데이터 ML 워크플로 오케스트레이터](/assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_3.png)

<div class="content-ad"></div>

## Rollup

Rollup은 워크플로 인스턴스의 상세 요약을 제공하여 각 단계의 상태와 각 상태의 단계 수를 자세히 설명합니다. 이는 현재 인스턴스 및 서브워크플로 또는 foreach 단계와 같은 중첩되지 않은 워크플로에서 단계를 평탄하게 처리합니다. 예를 들어, 성공적인 워크플로가 세 단계를 가지고 있는 경우, 해당 중 하나가 다섯 단계의 서브워크플로에 해당하는 경우, 롤업은 일곱 단계가 성공했음을 나타낼 것입니다. 롤업에서는 리프 단계만이 계산되며, 다른 단계들은 단순히 구체적인 워크플로를 가리키는 포인터로 사용됩니다.

Rollup은 비성공적인 단계에 대한 참조도 유지하여 단계 상태의 명확한 개요를 제공하고 중첩된 워크플로 내에서 문제가 되는 단계로 쉽게 이동할 수 있는 기능을 제공합니다. 워크플로 인스턴스에 대한 집계된 롤업은 현재 실행 데이터를 기본 롤업과 결합하여 계산됩니다. 현재 상태는 활성 단계의 상태를 기반으로 하며, foreach 및 서브워크플로 단계의 집계된 롤업을 포함합니다. 기본 롤업은 워크플로 인스턴스가 시작될 때 설정되며, 이전 실행에서의 인라인 단계(개별 foreach 및 서브워크플로를 제외한) 상태를 포함합니다.

서브워크플로 단계의 경우, 롤업은 단순히 서브워크플로 인스턴스의 롤업을 반영합니다. foreach 단계의 경우, 롤업은 foreach 단계의 기본 롤업과 현재 상태 롤업을 결합합니다. 기본값은 새 실행에서 다시 시작될 이전 실행의 집계된 롤업에서 파생됩니다. 현재 상태는 모든 반복이 종료 상태에 도달할 때까지 실행 중인 반복의 롤업을 집계하여 주기적으로 업데이트됩니다.

<div class="content-ad"></div>

이러한 과정들로 롤업 모델은 결국 일관성을 유지합니다. 아래 도표는 롤업의 간단한 예시를 보여주지만, 계산은 여러 수준의 중첩된 foreach와 서브워크플로와 함께 복잡하고 재귀적일 수 있습니다.

![Maestro Data ML Workflow Orchestrator at Netflix](/assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_4.png)

## Maestro 이벤트 발행

워크플로 정의, 워크플로 인스턴스 또는 단계 인스턴스가 변경되면 Maestro는 이벤트를 생성하고 내부적으로 처리한 후 외부 시스템에 처리된 이벤트를 게시합니다. Maestro에는 내부 및 외부 이벤트가 모두 있습니다. 내부 이벤트는 워크플로, 워크플로 인스턴스 또는 단계 인스턴스의 수명 주기 내에서 변경 사항을 추적합니다. 내부 큐로 게시되며 Maestro 내에서 처리됩니다. 내부 이벤트가 처리된 후, 일부는 외부 이벤트로 변환되어 외부 큐(예: SNS, Kafka)로 전송됩니다. 외부 이벤트는 하류 서비스를 위한 maestro 상태 변경 정보를 포함합니다. 이벤트 발행 흐름은 아래 도표에 설명되어 있습니다:

<div class="content-ad"></div>


![Maestro Event Processor](/assets/img/2024-08-03-MaestroDataMLWorkflowOrchestratoratNetflix_5.png)

As shown in the diagram, the Maestro event processor bridges the two aforementioned Maestro events. It listens on the internal queue to get the published internal events. Within the processor, the internal job event is processed based on its type and gets converted to an external event if needed. The notification publisher at the end emits the external event so that downstream services can consume.

The downstream services are mostly event-driven. The Maestro event carries the most useful message for downstream services to capture different changes in Maestro. In general, these changes can be classified into two categories: workflow change and instance status change. The workflow change event is associated with actions at workflow level, i.e definition or properties of a workflow has changed. Meanwhile, instance status change tracks status transition on workflow instance or step instance.

# Get Started with Maestro


<div class="content-ad"></div>

마에스트로는 Netflix 내에서 광범위하게 사용되어 왔고, 오늘 우리는 마에스트로 소스 코드를 공개로 제공하는 것에 흥분하고 있습니다. Netflix 외부에서의 workflow 개발을 가속화할 수 있는 마에스트로가 제공하는 확장성과 사용성에 대해 기대합니다. 마에스트로를 시도해보고 귀사 내에서 사용하며, 그 발전에 기여해 주시기를 초대합니다.

마에스트로 코드 저장소는 github.com/Netflix/maestro에서 찾을 수 있습니다. 마에스트로에 관한 질문, 생각 또는 의견이 있으시면, 마에스트로 저장소에서 GitHub 이슈를 만드십시오. 여러분의 소식을 기다리고 있겠습니다. 

우리는 워크플로 오케스트레이션을 더 나은 수준으로 이끌고 있으며, 지속적으로 새로운 문제와 도전을 해결하고 있습니다. 업데이트 소식을 기대해 주세요. 대규모 오케스트레이션 문제 해결에 열정적이시라면, 우리와 함께해 주세요.

# 감사의 글

<div class="content-ad"></div>

마에스트로 프로젝트에 기여한 다른 마에스트로 팀 멤버인 Binbing Hou, Zhuoran Dong, Brittany Truong, Deepak Ramalingam, Moctar Ba에게 감사드립니다. 전략과 요구 사항을 이끈 제품 매니저인 Ashim Pokharel에게도 감사드립니다. 또한 Netflix의 Andrew Seier, Romain Cledat, Olek Gorajek 및 기타 놀라운 동료들에게도 마에스트로 프로젝트에 기여한 데 대해 감사드립니다. Netflix의 엔지니어링 조직 리더인 Prashanth Ramdas, Eva Tse, David Noor, Charles Smith 및 기타 리더들에게도 건설적인 피드백과 제안을 제공해준 데 대해 감사드립니다.